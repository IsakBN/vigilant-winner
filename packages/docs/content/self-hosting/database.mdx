---
title: "Database Setup"
description: "Configure D1 and Neon Postgres for BundleNudge"
order: 3
---

# Database Setup

BundleNudge uses two databases:

- **Cloudflare D1** (SQLite) - App metadata, releases, devices, telemetry
- **Neon Postgres** - User authentication (Better Auth)

This guide covers schema setup, migrations, and backup strategies for both.

## Schema Overview

### D1 Database (SQLite)

The D1 database contains all application data:

```
┌─────────────────┐     ┌─────────────────┐     ┌─────────────────┐
│      apps       │────▶│    releases     │────▶│  release_stats  │
└─────────────────┘     └─────────────────┘     └─────────────────┘
        │                       │
        │                       │
        ▼                       ▼
┌─────────────────┐     ┌─────────────────┐
│    channels     │     │telemetry_events │
└─────────────────┘     └─────────────────┘
        │
        ▼
┌─────────────────┐     ┌─────────────────┐
│    devices      │────▶│ health_reports  │
└─────────────────┘     └─────────────────┘
```

**Core Tables:**

| Table | Description |
|-------|-------------|
| `apps` | Registered applications |
| `releases` | OTA update bundles |
| `channels` | Deployment environments (prod, staging, dev) |
| `devices` | Registered devices |
| `api_keys` | API authentication keys |
| `webhooks` | Outgoing webhook configurations |
| `telemetry_events` | SDK telemetry data |
| `health_reports` | Device health metrics |
| `release_stats` | Aggregated release statistics |

**Team & Billing Tables:**

| Table | Description |
|-------|-------------|
| `organizations` | Team/workspace accounts |
| `organization_members` | Team membership |
| `subscriptions` | Subscription records |
| `invoices` | Billing invoices |

### Neon Postgres (Auth)

The Postgres database handles authentication:

| Table | Description |
|-------|-------------|
| `users` | User accounts |
| `user_sessions` | Active sessions |
| `email_verification_tokens` | Email verification |
| `password_reset_tokens` | Password reset |

## D1 Setup

### Creating the Database

If you haven't already:

```bash
wrangler d1 create bundlenudge-db
```

### Running Migrations

BundleNudge uses Drizzle ORM for schema management.

#### Generate Migrations

```bash
cd packages/api

# Generate SQL migrations from TypeScript schema
pnpm drizzle-kit generate:sqlite --out ./migrations
```

#### Apply Migrations to D1

```bash
# List pending migrations
wrangler d1 migrations list bundlenudge-db

# Apply all pending migrations
wrangler d1 migrations apply bundlenudge-db
```

#### Manual Migration

For custom schema changes:

```bash
# Create a new migration file
mkdir -p migrations
touch migrations/0001_custom_change.sql
```

Edit the SQL file:

```sql
-- migrations/0001_custom_change.sql
ALTER TABLE apps ADD COLUMN custom_field TEXT;
CREATE INDEX apps_custom_field_idx ON apps(custom_field);
```

Apply:

```bash
wrangler d1 execute bundlenudge-db --file=migrations/0001_custom_change.sql
```

### Schema Reference

Here's the complete D1 schema:

```sql
-- Applications
CREATE TABLE apps (
  id TEXT PRIMARY KEY,
  name TEXT NOT NULL,
  bundle_id TEXT,
  platform TEXT NOT NULL CHECK (platform IN ('ios', 'android')),
  owner_id TEXT NOT NULL,
  api_key TEXT NOT NULL,
  webhook_secret TEXT NOT NULL,
  settings TEXT, -- JSON
  created_at INTEGER NOT NULL,
  updated_at INTEGER NOT NULL,
  deleted_at INTEGER
);

CREATE INDEX apps_owner_idx ON apps(owner_id);
CREATE INDEX apps_bundle_id_idx ON apps(bundle_id);

-- Releases
CREATE TABLE releases (
  id TEXT PRIMARY KEY,
  app_id TEXT NOT NULL REFERENCES apps(id),
  channel_id TEXT REFERENCES channels(id),
  version TEXT NOT NULL,
  bundle_url TEXT NOT NULL,
  bundle_size INTEGER NOT NULL,
  bundle_hash TEXT NOT NULL,
  rollout_percentage INTEGER DEFAULT 100,
  targeting_rules TEXT, -- JSON
  release_notes TEXT,
  status TEXT DEFAULT 'active' CHECK (status IN ('active', 'paused', 'rolled_back')),
  rollback_reason TEXT,
  min_app_version TEXT,
  max_app_version TEXT,
  created_at INTEGER NOT NULL,
  updated_at INTEGER NOT NULL
);

CREATE INDEX releases_app_idx ON releases(app_id);
CREATE INDEX releases_channel_idx ON releases(channel_id);
CREATE INDEX releases_status_idx ON releases(status);

-- Channels
CREATE TABLE channels (
  id TEXT PRIMARY KEY,
  app_id TEXT NOT NULL REFERENCES apps(id),
  name TEXT NOT NULL,
  display_name TEXT NOT NULL,
  description TEXT,
  is_default INTEGER DEFAULT 0,
  rollout_percentage INTEGER DEFAULT 100,
  targeting_rules TEXT, -- JSON
  active_release_id TEXT,
  created_at INTEGER NOT NULL,
  updated_at INTEGER NOT NULL
);

CREATE INDEX channels_app_idx ON channels(app_id);
CREATE UNIQUE INDEX channels_app_name_idx ON channels(app_id, name);

-- Devices
CREATE TABLE devices (
  id TEXT PRIMARY KEY,
  app_id TEXT NOT NULL REFERENCES apps(id),
  device_id TEXT NOT NULL,
  platform TEXT NOT NULL CHECK (platform IN ('ios', 'android')),
  os_version TEXT,
  device_model TEXT,
  timezone TEXT,
  locale TEXT,
  app_version TEXT NOT NULL,
  current_bundle_version TEXT,
  current_bundle_hash TEXT,
  target_group TEXT,
  token_hash TEXT,
  token_expires_at INTEGER,
  last_seen_at INTEGER,
  revoked_at INTEGER,
  crash_count INTEGER DEFAULT 0,
  created_at INTEGER NOT NULL
);

CREATE INDEX devices_app_idx ON devices(app_id);
CREATE INDEX devices_device_id_idx ON devices(device_id);
CREATE UNIQUE INDEX devices_app_device_idx ON devices(app_id, device_id);

-- API Keys
CREATE TABLE api_keys (
  id TEXT PRIMARY KEY,
  app_id TEXT NOT NULL REFERENCES apps(id),
  name TEXT NOT NULL,
  key_prefix TEXT NOT NULL,
  key_hash TEXT NOT NULL,
  permissions TEXT NOT NULL, -- JSON array
  last_used_at INTEGER,
  revoked_at INTEGER,
  created_at INTEGER NOT NULL
);

CREATE INDEX api_keys_app_idx ON api_keys(app_id);
CREATE INDEX api_keys_prefix_idx ON api_keys(key_prefix);

-- Webhooks
CREATE TABLE webhooks (
  id TEXT PRIMARY KEY,
  app_id TEXT NOT NULL REFERENCES apps(id),
  url TEXT NOT NULL,
  events TEXT NOT NULL, -- JSON array
  secret TEXT NOT NULL,
  is_active INTEGER DEFAULT 1,
  last_triggered_at INTEGER,
  created_at INTEGER NOT NULL,
  updated_at INTEGER NOT NULL
);

-- Telemetry
CREATE TABLE telemetry_events (
  id TEXT PRIMARY KEY,
  device_id TEXT NOT NULL,
  app_id TEXT NOT NULL,
  event_type TEXT NOT NULL,
  release_id TEXT,
  bundle_version TEXT,
  error_code TEXT,
  error_message TEXT,
  metadata TEXT, -- JSON
  timestamp INTEGER NOT NULL,
  created_at INTEGER NOT NULL
);

CREATE INDEX telemetry_app_idx ON telemetry_events(app_id);
CREATE INDEX telemetry_device_idx ON telemetry_events(device_id);
CREATE INDEX telemetry_timestamp_idx ON telemetry_events(timestamp);

-- Release Stats
CREATE TABLE release_stats (
  release_id TEXT PRIMARY KEY REFERENCES releases(id),
  total_downloads INTEGER DEFAULT 0,
  total_installs INTEGER DEFAULT 0,
  total_rollbacks INTEGER DEFAULT 0,
  total_crashes INTEGER DEFAULT 0,
  last_updated_at INTEGER NOT NULL
);
```

## Neon Postgres Setup

### Create Neon Project

1. Go to [Neon Console](https://console.neon.tech)
2. Click **Create Project**
3. Name it: `bundlenudge-auth`
4. Select region closest to your users
5. Copy the connection string

### Configure Connection

Add to Wrangler secrets:

```bash
wrangler secret put DATABASE_URL
# Enter: postgres://user:pass@ep-xxx.region.aws.neon.tech/neondb?sslmode=require
```

### Auth Schema

Better Auth manages its own schema. Initialize it:

```bash
cd packages/api

# Run Better Auth migrations
pnpm better-auth migrate
```

Or manually create the tables:

```sql
-- Users
CREATE TABLE users (
  id TEXT PRIMARY KEY,
  email TEXT NOT NULL UNIQUE,
  email_verified BOOLEAN DEFAULT FALSE,
  name TEXT,
  image TEXT,
  password_hash TEXT,
  created_at TIMESTAMP DEFAULT NOW(),
  updated_at TIMESTAMP DEFAULT NOW()
);

CREATE INDEX users_email_idx ON users(email);

-- Sessions
CREATE TABLE user_sessions (
  id TEXT PRIMARY KEY,
  user_id TEXT NOT NULL REFERENCES users(id) ON DELETE CASCADE,
  token_hash TEXT NOT NULL,
  expires_at TIMESTAMP NOT NULL,
  created_at TIMESTAMP DEFAULT NOW()
);

CREATE INDEX sessions_user_idx ON user_sessions(user_id);
CREATE INDEX sessions_token_idx ON user_sessions(token_hash);

-- Email Verification
CREATE TABLE email_verification_tokens (
  id TEXT PRIMARY KEY,
  user_id TEXT NOT NULL REFERENCES users(id) ON DELETE CASCADE,
  token_hash TEXT NOT NULL,
  expires_at TIMESTAMP NOT NULL,
  created_at TIMESTAMP DEFAULT NOW()
);

-- Password Reset
CREATE TABLE password_reset_tokens (
  id TEXT PRIMARY KEY,
  user_id TEXT NOT NULL REFERENCES users(id) ON DELETE CASCADE,
  token_hash TEXT NOT NULL,
  expires_at TIMESTAMP NOT NULL,
  created_at TIMESTAMP DEFAULT NOW()
);
```

## Backup Strategies

### D1 Backups

#### Automatic Backups

D1 includes automatic point-in-time recovery for the last 30 days (Paid plan).

#### Manual Export

Export data regularly:

```bash
# Export all tables
wrangler d1 export bundlenudge-db --output=backup.sql

# Export specific table
wrangler d1 execute bundlenudge-db \
  --command="SELECT * FROM apps" \
  --output=json > apps_backup.json
```

#### Scheduled Backups

Create a Worker for automated backups:

```typescript
// backup-worker.ts
export default {
  async scheduled(event: ScheduledEvent, env: Env) {
    const tables = ['apps', 'releases', 'devices', 'channels'];

    for (const table of tables) {
      const result = await env.DB.prepare(
        `SELECT * FROM ${table}`
      ).all();

      const timestamp = new Date().toISOString().split('T')[0];
      const key = `backups/${timestamp}/${table}.json`;

      await env.BACKUP_BUCKET.put(key, JSON.stringify(result.results));
    }
  },
};
```

Schedule daily:

```toml
[triggers]
crons = ["0 3 * * *"]  # 3 AM daily
```

### Neon Backups

#### Automatic Backups

Neon provides:
- **Branching**: Instant database copies
- **Point-in-time recovery**: Restore to any point (Pro plan)

#### Create Branch Backup

```bash
# Via Neon CLI
neon branches create --name backup-$(date +%Y%m%d)

# Via API
curl -X POST "https://console.neon.tech/api/v2/projects/{project_id}/branches" \
  -H "Authorization: Bearer $NEON_API_KEY" \
  -d '{"branch": {"name": "backup-20240115"}}'
```

#### Export to SQL

```bash
pg_dump $DATABASE_URL > backup.sql
```

### Disaster Recovery

#### Full Recovery Procedure

1. **D1 Recovery**:
   ```bash
   # Restore from backup
   wrangler d1 execute bundlenudge-db --file=backup.sql
   ```

2. **Neon Recovery**:
   ```bash
   # Restore from branch
   neon branches restore backup-20240115 --target main
   ```

3. **R2 Recovery**:
   R2 includes object versioning. Enable it:
   ```bash
   wrangler r2 bucket versioning enable --bucket bundlenudge-bundles
   ```

## Monitoring

### D1 Metrics

View in Cloudflare Dashboard:
- **Workers & Pages** > **D1** > **bundlenudge-db** > **Metrics**

Key metrics:
- Rows read/written
- Query latency
- Storage used

### Neon Metrics

View in Neon Console:
- Connection count
- Query performance
- Storage usage

### Custom Monitoring

Add query logging to your Workers:

```typescript
// Log slow queries
const start = Date.now();
const result = await env.DB.prepare(query).all();
const duration = Date.now() - start;

if (duration > 100) {
  console.log(`Slow query (${duration}ms): ${query}`);
}
```

## Optimization Tips

### D1 Performance

1. **Use indexes** for frequently queried columns:
   ```sql
   CREATE INDEX idx_releases_created ON releases(created_at DESC);
   ```

2. **Batch reads** instead of N+1 queries:
   ```typescript
   // Bad: N+1
   for (const appId of appIds) {
     await db.prepare('SELECT * FROM releases WHERE app_id = ?').bind(appId).all();
   }

   // Good: Batch
   const placeholders = appIds.map(() => '?').join(',');
   await db.prepare(`SELECT * FROM releases WHERE app_id IN (${placeholders})`).bind(...appIds).all();
   ```

3. **Limit result sets**:
   ```sql
   SELECT * FROM telemetry_events
   WHERE app_id = ?
   ORDER BY created_at DESC
   LIMIT 100
   ```

### Neon Performance

1. **Use connection pooling**:
   ```
   DATABASE_URL=postgres://...?pgbouncer=true&pool_timeout=0
   ```

2. **Enable prepared statements** for repeated queries

3. **Use Neon branching** for testing schema changes

## Troubleshooting

### "Database not found"

```bash
# Verify database exists
wrangler d1 list

# Check binding in wrangler.toml
[[d1_databases]]
binding = "DB"
database_name = "bundlenudge-db"
database_id = "correct-id-here"
```

### "Connection refused" (Neon)

- Check that `sslmode=require` is in connection string
- Verify IP isn't blocked (Neon Pro feature)
- Check connection limit (25 for free tier)

### Migration Errors

```bash
# Check current migration state
wrangler d1 migrations list bundlenudge-db

# Reset and re-apply (development only!)
wrangler d1 execute bundlenudge-db --command="DROP TABLE IF EXISTS __drizzle_migrations"
wrangler d1 migrations apply bundlenudge-db
```

### Query Performance

Analyze slow queries:

```sql
-- D1: Explain query plan
EXPLAIN QUERY PLAN SELECT * FROM releases WHERE app_id = 'xxx';
```

Add missing indexes based on the output.
